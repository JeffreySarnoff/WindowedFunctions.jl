var documenterSearchIndex = {"docs":
[{"location":"design/dispatch/#**Simplifying-Dispatch**","page":"-","title":"Simplifying Dispatch","text":"","category":"section"},{"location":"design/dispatch/","page":"-","title":"-","text":"","category":"page"},{"location":"design/dispatch/#unweighted-and-weighted","page":"-","title":"unweighted and weighted","text":"","category":"section"},{"location":"design/dispatch/","page":"-","title":"-","text":"<approach>(windowed_fn, window_width, data_seq;\n                    padding=pad, atend=true)\n\n<approach>(windowed_fn, window_width, data_seq, weighting;\n                    padding=pad, atend=true)","category":"page"},{"location":"design/dispatch/","page":"-","title":"-","text":"","category":"page"},{"location":"design/dispatch/#unpadded,-padded-at-start,-padded-at-end","page":"-","title":"unpadded, padded at start, padded at end","text":"","category":"section"},{"location":"design/dispatch/#*unweighted*","page":"-","title":"unweighted","text":"","category":"section"},{"location":"design/dispatch/","page":"-","title":"-","text":"<approach>(windowed_fn, window_width, data_seq)\n\n<approach>(windowed_fn, window_width, data_seq,\n                    padding)\n\n<approach>(windowed_fn, window_width, data_seq,\n                    padding, atend)","category":"page"},{"location":"design/dispatch/#*weighted*","page":"-","title":"weighted","text":"","category":"section"},{"location":"design/dispatch/","page":"-","title":"-","text":"<approach>(windowed_fn, window_width, data_seq, weighting)\n\n<approach>(windowed_fn, window_width, data_seq, weighting,\n                    padding)\n\n<approach>(windowed_fn, window_width, data_seq, weighting,\n                    padding, atend)","category":"page"},{"location":"references/#links","page":"References","title":"links","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"wavefront (moving and tumbling windows)","category":"page"},{"location":"references/","page":"References","title":"References","text":"ksqldb (windowed aggregation)","category":"page"},{"location":"references/","page":"References","title":"References","text":"survey of window types","category":"page"},{"location":"references/","page":"References","title":"References","text":"in-order sliding-window aggregation","category":"page"},{"location":"references/","page":"References","title":"References","text":"efficient incremental computation of aggregations","category":"page"},{"location":"references/","page":"References","title":"References","text":"tutorial: sliding-window aggregation algorithms","category":"page"},{"location":"references/#citations","page":"References","title":"citations","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"[VGT2023] \nauthors Verwiebe, J., Grulich, P.M., Traub, J. et al.\ntitle Survey of window types for aggregation in stream processing systems\njournal The VLDB Journal (2023)\ndoi 10.1007/s00778-022-00778-6\npaper pdf","category":"page"},{"location":"references/","page":"References","title":"References","text":"[THS2021] \nauthors Tangwongsan, K., Hirzel, M. & Schneider, S.\ntitle In-order sliding-window aggregation in worst-case constant time\njournal The VLDB Journal 30, 933–957 (2021)\ndoi 10.1007/s00778-021-00668-3\npaper pdf","category":"page"},{"location":"references/","page":"References","title":"References","text":"[ZAT2021] \nauthors Zhang. C., Akbarinia, R., Toumani, F.\ntitle Efficient Incremental Computation of Aggregations over Sliding Windows\nproceedings 27th ACM SIGKDD Conference, 2136-2144 (2021)\ndoi 10.1145/3447548.3467360\npaper pdf","category":"page"},{"location":"references/","page":"References","title":"References","text":"[TJG2021] \nauthors Traub, J., Grulich, P.M., Cuellar, A.R. et. al.\ntitle Scotty: General and Efficient Open-source Window Aggregation\njournal ACM Trans. Database Syst. 46, 1, (2021)\ndoi 10.1145/3433675\npaper pdf","category":"page"},{"location":"references/","page":"References","title":"References","text":"[HST2017] \nauthors Hirzel, M., Schneider, S., Tangwongsan, K.\ntitle Tutorial: Sliding-Window Aggregation Algorithms\nproceedings DEBS ’17, Barcelona, Spain (2017)\ndoi 10.1145/3093742.3095107\npaper pdf","category":"page"},{"location":"approach/datastreams/","page":"datastreams","title":"datastreams","text":"    datastreams","category":"page"},{"location":"approach/datastreams/","page":"datastreams","title":"datastreams","text":"There are four sorts of datastreams available when\n`rolling`, `tiling`, or `running` windowed functions.","category":"page"},{"location":"approach/datastreams/","page":"datastreams","title":"datastreams","text":"datastream window functions over subsequences of\n1 Vector max, sum, mean individual values\n2 Vectors cor, cov ordered pairs\n3 Vectors clamp, midof3 ordered triples\n  \na Matrix as with 1 Vector column values\neach matrix column is processed as a single vector  ","category":"page"},{"location":"approach/datastreams/","page":"datastreams","title":"datastreams","text":"Each datastream is composed of one or more data sequence[s].  The most fundamental datastream is the sequence of values that populate a vector. A function of one argument is applied over successive windows onto the data vector. Where the datastream is a matrix, every column is an independant vector.","category":"page"},{"location":"approach/datastreams/","page":"datastreams","title":"datastreams","text":"","category":"page"},{"location":"approach/datastreams/#[using-datastreams](../use/datastreams.md)","page":"datastreams","title":"using datastreams","text":"","category":"section"},{"location":"approach/datastreams/","page":"datastreams","title":"datastreams","text":"See also: rolling,           tiling,           running","category":"page"},{"location":"tech/windowsorts/#the-kinds-of-window-extent","page":"-","title":"the kinds of window extent","text":"","category":"section"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"quantity extent given by utilizes\nspan index separation positions\nduration elapsed time timestamps\ncount tally of occurances events\nsession content obtained activities\n  ","category":"page"},{"location":"tech/windowsorts/#the-kinds-of-positional-skip","page":"-","title":"the kinds of positional skip","text":"","category":"section"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"fixed\nexpanding\ndynamic","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"https://materialize.com/docs/transform-data/patterns/temporal-filters/","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"period [step] –  before a new window begins","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"(number of indices / amount of time / count of occurances / activity)","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"Tumbling windows are what we call windows when their duration equals their period (the amount of time before a new window begins). This creates fixed-size, contiguous, non-overlapping time intervals where each record belongs to exactly one interval.","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"Hopping windows are windows whose duration is an integer multiple of their period. This creates fixed-size windows that may overlap, with records belonging to multiple windows.","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"Sliding windows are windows whose period approaches the limit of 0. This creates fixed-size windows that appear to slide continuously forward in time. Records may belong to more than one interval.","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"count-based, delta-based, time-based, punctuation-based","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"rolling weighted expanding windows","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"event-time, processing-time","category":"page"},{"location":"tech/windowsorts/#the-modes-of-window-advancement","page":"-","title":"the modes of window advancement","text":"","category":"section"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"A window that covers <first, last> advances to <last, last+(last-first)>.","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"A window moves by advancing its start by jump and covering its extent","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"Each window has a fixed or dynamic or expanding extent\nEach window has a fixed or dynamic or expanding jump","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"name increment overlap gap\nslide fixed extent-1 none\ntile fixed none none\ntumble fixed no gapless\noverlap fixed no gapless\nhop fixed extent-jump jump-extent\nsession dynamic no no","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"Every windows has a width (span). The width  There are two distinct sorts of windows that are taken over data: rolling and tiled.  ","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"Rolling windows advance step-by-step over the data\neach step advances the indices widthned by 1\nTiled windows advance in larger strides over the data\neach stride advances the indices widthned by a fixed multistep","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"With tiled windows, the tiling (the width that describes the indices covered by each tile) and the multistep increment are the same in most uses. An example of this is summarizing a week of daily data with a tiling of 7 and then moving to the following week with a multistep of 7.","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"To use a multistep increment that is less than the tiling is permitted. As an example, summarize two weeks of daily data with a tiling of 14 and skip over one week with a multistep of 7 to allow you to analyze two week intervals one week at a time.","category":"page"},{"location":"tech/windowsorts/","page":"-","title":"-","text":"To use a multistep increment that exceeds the tiling is permitted. As an example, summarize a week of daily data with a tiling of 7 and skip over two weeks with a multistep of 14 to allow you to analyze odd weeks and use that analysis along with the even weeks to constrain a model.","category":"page"},{"location":"diagrams/valuestatistics/","page":"iconography","title":"iconography","text":"(Image: ValuesAndStatistics)","category":"page"},{"location":"use/atend/","page":"-","title":"-","text":"under construction (see tests)","category":"page"},{"location":"use/atend/#[approaching-atend](../approach/atend.md)","page":"-","title":"approaching atend","text":"","category":"section"},{"location":"approach/weights/","page":"weights","title":"weights","text":"    apply functions over windows into weighted data\n\n`rolling`, `tiling`, and `running` all provide data weighting.\n\nThe functions for weighted data follow the unweighted function signatures.\n- the weighting is given after the data, as the last positional arg\n\nWeighting for a data vector is given as one of the subtypes of StatsBase.AbstractWeights","category":"page"},{"location":"approach/weights/","page":"weights","title":"weights","text":"To use myweights::Vector{<:Real} as weights","category":"page"},{"location":"approach/weights/","page":"weights","title":"weights","text":"When a window is provided weights, is important to normalize those weights. For most applications, the weights should sum to 1.0 (or just less than 1.0).","category":"page"},{"location":"approach/weights/","page":"weights","title":"weights","text":"The function safeweights(weights::AbstractVector{<:AbstractFloat}) does the this with care. The sum of a weight vector returned from  safeweights is assured to be <= 1.0 while staying within a small multiple ofeps(eltype(weights)).","category":"page"},{"location":"approach/weights/","page":"weights","title":"weights","text":"scale the values so they sum to 1.0 (or a few eps less than 1.0)\nmyweights1 = safeweights(myweights1)\nconvert the values to StatsBase.AnalyticWeights (usually)\nweighting = AnalyticWeights(myweights1)","category":"page"},{"location":"approach/weights/","page":"weights","title":"weights","text":"","category":"page"},{"location":"approach/weights/#[using-weights](../use/weights.md)","page":"weights","title":"using weights","text":"","category":"section"},{"location":"approach/weights/","page":"weights","title":"weights","text":"See also: safeweights,           datastreams","category":"page"},{"location":"use/tiling/","page":"-","title":"-","text":"under construction (see tests)","category":"page"},{"location":"use/tiling/#[approaching-tiling](../approach/tiling.md)","page":"-","title":"approaching tiling","text":"","category":"section"},{"location":"use/datastreams/","page":"-","title":"-","text":"under construction (see tests)","category":"page"},{"location":"use/datastreams/#[approaching-datastreams](../approach/datastreams.md)","page":"-","title":"approaching datastreams","text":"","category":"section"},{"location":"use/datastreams/#Supported-Data-Sequences","page":"-","title":"Supported Data Sequences","text":"","category":"section"},{"location":"use/datastreams/#sequence","page":"-","title":"sequence","text":"","category":"section"},{"location":"use/datastreams/","page":"-","title":"-","text":"unweighted\n≺ rolling | tiling | running ≻(fn, width, seq)\nweighted\n≺ rolling | tiling | running ≻(fn, width, seq, weights)","category":"page"},{"location":"use/datastreams/#multisequence","page":"-","title":"multisequence","text":"","category":"section"},{"location":"use/datastreams/","page":"-","title":"-","text":"unweighted\n≺ rolling | tiling | running ≻(fn, width, seq1, seq2)\n≺ rolling | tiling | running ≻(fn, width, seq1, seq2, seq3)\nweighted\n≺ rolling | tiling | running ≻(fn, width, seq1, seq2, weighting)\n≺ rolling | tiling | running ≻(fn, width, seq1, seq2, seq3, weighting)","category":"page"},{"location":"use/datastreams/","page":"-","title":"-","text":"multisequence  signature\n  ≺ rolling | tiling | running ≻(fn, width, rest...)\n  rest are the remaining args, they follow width\n  \nunweighted  \n  (seq1, seq2)\n  (seq1, seq2, seq3)\n  \nshared weights  \n  (seq1, seq2, weights)\n  (seq1, seq2, seq3, weights)\n  \nunique weights  \n  (seq1, seq2, [weights1, weights2])\n  (seq1, seq2, seq3, [weights1, weights2, weights3])\n  ","category":"page"},{"location":"use/datastreams/#matrix","page":"-","title":"matrix","text":"","category":"section"},{"location":"use/datastreams/","page":"-","title":"-","text":"columns are data sequences\neach column is processed independently\nthe windowed fn is applied columnwise","category":"page"},{"location":"use/datastreams/#*unweighted*","page":"-","title":"unweighted","text":"","category":"section"},{"location":"use/datastreams/","page":"-","title":"-","text":"≺ rolling | tiling | running ≻(fn, width, datamatrix)","category":"page"},{"location":"use/datastreams/#*weighted-(shared-weights)*","page":"-","title":"weighted (shared weights)","text":"","category":"section"},{"location":"use/datastreams/","page":"-","title":"-","text":"≺ rolling | tiling | running ≻(fn, width, datamatrix, weights)","category":"page"},{"location":"use/datastreams/#*weighted-(column-weights)*","page":"-","title":"weighted (column weights)","text":"","category":"section"},{"location":"use/datastreams/","page":"-","title":"-","text":"≺ rolling | tiling | running ≻(fn, width, datamatrix, weightmatrix)","category":"page"},{"location":"use/datastreams/","page":"-","title":"-","text":"","category":"page"},{"location":"design/signatures/#**Positional-Signatures**","page":"-","title":"Positional Signatures","text":"","category":"section"},{"location":"design/signatures/#*each-approach-subsumes-64-signatures*","page":"-","title":"each approach subsumes 64 signatures","text":"","category":"section"},{"location":"design/signatures/","page":"-","title":"-","text":"With 2 keyword args, there are 4 positional signatures (one for each state shown in approach).\nWith the 4 data configurations that becomes 4x4 = 16 signatures.\nWith the 3 ways to weight + unweighted this gives 16x4 = 64 signatures.","category":"page"},{"location":"design/signatures/#*enfolding-dispatch*","page":"-","title":"enfolding dispatch","text":"","category":"section"},{"location":"design/signatures/","page":"-","title":"-","text":"unweighted","category":"page"},{"location":"design/signatures/","page":"-","title":"-","text":"function <approach>(windowed_fn, window_width, data_seq;\n                    padding=pad, atend=true)\n  if !atend # the common case\n    if padding === nopadding # the default case\n      <approach>(windowed_fn, window_width, data_seq)\n    else\n      <approach>(windowed_fn, window_width, data_seq, padding)\n    end\n  else\n    if padding === nopadding # the default case\n      <approach>(windowed_fn, window_width, data_seq, atend)\n    else\n      <approach>(windowed_fn, window_width, data_seq, padding, atend)\n    end\n  end\nend","category":"page"},{"location":"design/signatures/","page":"-","title":"-","text":"weighted","category":"page"},{"location":"design/signatures/","page":"-","title":"-","text":"function <approach>(windowed_fn, window_width, data_seq, weighting;\n                    padding=pad, atend=true)\n  if !atend # the common case\n    if padding === nopadding # the default case\n      <approach>(windowed_fn, window_width, data_seq, weighting)\n    else\n      <approach>(windowed_fn, window_width, data_seq, weighting, padding)\n    end\n  else\n    if padding === nopadding # the default case\n      <approach>(windowed_fn, window_width, data_seq, weighting, atend)\n    else\n      <approach>(windowed_fn, window_width, data_seq, weighting, padding, atend)\n    end\n  end\nend","category":"page"},{"location":"design/patterns/#using-constitutive-parts","page":"-","title":"using constitutive parts","text":"","category":"section"},{"location":"design/patterns/","page":"-","title":"-","text":"``` ohlcv(open, high, low, close, vol) =    (; open, high, low, close, vol)","category":"page"},{"location":"design/patterns/","page":"-","title":"-","text":"open, close, vol = map(x->a[x], (:open, :close, :vol)) high, low, vol = map(x->a[x], (:high, :low, :vol))","category":"page"},{"location":"design/patterns/","page":"-","title":"-","text":"ocv(ohlcv) =   (open = ohlcv.open, close = ohlcv.close, vol = ohlcv.vol)","category":"page"},{"location":"design/patterns/","page":"-","title":"-","text":"hlv(ohlcv) =   (high = ohlcv.high, low = ohlcv.low, vol = ohlcv.vol)","category":"page"},{"location":"design/patterns/","page":"-","title":"-","text":"weighted_change(ocv) = (ocv.close - ocv.open) * log(ocv.vol)","category":"page"},{"location":"design/patterns/","page":"-","title":"-","text":"weighted_movement(hlv) = (hlv.high - hlv.low) * log(hlv.vol)","category":"page"},{"location":"design/patterns/","page":"-","title":"-","text":"pricedynamism(ohlcv) =    weightedchange(ocv(ohlcv)) * weighted_movement(hlv(ohlcv))","category":"page"},{"location":"design/patterns/","page":"-","title":"-","text":"data = openhighlowclosevolume  Defining a window-ready function of 6 args  from two constitutive functional parts.","category":"page"},{"location":"design/patterns/","page":"-","title":"-","text":"fn(v1,v2,v3,v4,v5,v6) = fnab(fna(v1, v2, v3), fnb(v3, v4, v5))","category":"page"},{"location":"design/patterns/","page":"-","title":"-","text":"","category":"page"},{"location":"diagrams/tiling/#Tiling-covers-adjacent-subsequences-of-nonoverlapping-data-with-a-moving-window-that-advances-by-its-own-width.","page":"tiling","title":"Tiling covers adjacent subsequences of nonoverlapping data with a moving window that advances by its own width.","text":"","category":"section"},{"location":"diagrams/tiling/","page":"tiling","title":"tiling","text":"","category":"page"},{"location":"diagrams/tiling/","page":"tiling","title":"tiling","text":"(Image: tiling image)","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"    safeweights(<:AbstractVector{T})::AbstractVector{T}","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"ensures that the sum of the weights","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"does not exceed 1\napproaches or is equal to 1","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"one(T) >= safesum > prevfloat(one(T), k)","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"safesum = sum(safeweights(weights))\nk <= ceil(1 + log10(wlength) + wlength^(5/16))\nwlength = length(weights)","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"note: This normalization is not the same as calling LinearAlgebra.normalize(weights); that divides each weight by their 2-norm (the sqrt of the sum of squares). If your application expects weights to be normalized using something other the 1-norm, do the normalization yourself.","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"","category":"page"},{"location":"approach/safeweights/","page":"-","title":"-","text":"See also: weights","category":"page"},{"location":"diagrams/sequentialdata/","page":"rolling","title":"rolling","text":"(Image: SequentialDataStreams)","category":"page"},{"location":"approach/padding/","page":"padding","title":"padding","text":"   padding -- optional keyword argument","category":"page"},{"location":"approach/padding/","page":"padding","title":"padding","text":"By definition, applying a windowed function over data will result in fewer items than are in the original data. To add the missing items, select a padding value using the padding keyword argument e.g. padding=missing.","category":"page"},{"location":"approach/padding/","page":"padding","title":"padding","text":"By default, padding is applied at the begining of the result.","category":"page"},{"location":"approach/padding/","page":"padding","title":"padding","text":"by default, the padding value is placed at the lowest indices","category":"page"},{"location":"approach/padding/","page":"padding","title":"padding","text":"To apply padding at the end of the result, set atend=true.","category":"page"},{"location":"approach/padding/","page":"padding","title":"padding","text":"that way the padding value is placed at the highest indices","category":"page"},{"location":"approach/padding/#[using-padding](../use/padding.md)","page":"padding","title":"using padding","text":"","category":"section"},{"location":"approach/padding/","page":"padding","title":"padding","text":"See also: atend,           rolling,           tiling,           running","category":"page"},{"location":"design/stratified_internals/#rolling-functions-over-windowed-data","page":"-","title":"rolling functions over windowed data","text":"","category":"section"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"basic rolling\ngiven a data sequence of N elements\nusing a data window that widths S indices\none obtains N - S + 1 result values\npadded rolling\ngiven a data sequence of N elements\nusing a data window that widths S indices\none obtains  N - S + 1 result values\nand provides S - 1 elements that pad","category":"page"},{"location":"design/stratified_internals/#rolling-is-built-from-three-internal-functions","page":"-","title":"rolling is built from three internal functions","text":"","category":"section"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"basic_rolling\nthe result has fewer elements than the data has\npadfirst_rolling\nthe padding elements occupy the lowest indices of the result\npadfinal_rolling\nthe padding elements occupy the highest indices of the result","category":"page"},{"location":"design/stratified_internals/#unweighted-rolling","page":"-","title":"unweighted rolling","text":"","category":"section"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"function rolling(fn1, width, data; padding, atend)\n\n    if padding === nopadding\n       basic_rolling(fn1, width, data)\n    elseif !atend\n       padfirst_rolling(fn1, width, data, padding)\n    else\n       padfinal_rolling(fn1, width, data, padding)\n    end\n\nend","category":"page"},{"location":"design/stratified_internals/#weighted-rolling","page":"-","title":"weighted rolling","text":"","category":"section"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"function rolling(fn1, width, data, weights; padding, atend)\n\n    if padding === nopadding\n       basic_rolling(fn1, width, data, weights)\n    elseif !atend\n       padfirst_rolling(fn1, width, data, weights, padding)\n    else\n       padfinal_rolling(fn1, width, data, weights, padding)\n    end\n\nend","category":"page"},{"location":"design/stratified_internals/#processing","page":"-","title":"processing","text":"","category":"section"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"unweighted \nthe current window on the data is obtained current_data\nthe function is applied to the current_data rolling_value","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"with weights \nthe current window on the data is obtained current_data\nthe current_data is scaled by the weights weighted_data\nthe function is applied to the weighted_data rolling_value","category":"page"},{"location":"design/stratified_internals/#additional-coverage","page":"-","title":"additional coverage","text":"","category":"section"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"There are similar implementations for functions of 2, 3 arguments.","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"function rolling(fn2, width, data1, data2; \n                padding, atend)\n\n    if padding === nopadding\n       basic_rolling(fn2, width, data1, data2)\n    elseif !atend\n       padfirst_rolling(fn2, width, data1, data2, padding)\n    else\n       padfinal_rolling(fn2, width, data1, data2, padding)\n    end\n\nend","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"function rolling(fn2, width, data1, data2, weights1, weights2;\n                 padding, atend)\n\n    if padding === nopadding\n       basic_rolling(fn2, width, data1, data2,\n                                weights1, weights2)\n    elseif !atend\n       padfirst_rolling(fn2, width, data1, data2, \n                                   weights1, weights2, padding)\n    else\n       padfinal_rolling(fn2, width, data1, data2,\n                                   weights1, weights2, padding)\n    end\n\nend","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"","category":"page"},{"location":"design/stratified_internals/","page":"-","title":"-","text":"signatures returns\nfn1(x) scalar\nfn2(x,y) scalar\nfn3(x,y,z) scalar","category":"page"},{"location":"design/approach/","page":"-","title":"-","text":"This package supports distinct approaches to appling a  moving window function over data sequences. The core design develops each approach in the same way. This simplifies development, mitigates unexpected corner cases, and improves reliability.","category":"page"},{"location":"design/approach/","page":"-","title":"-","text":"There are three approachs:  running,  tiling, and  rolling.","category":"page"},{"location":"design/approach/","page":"-","title":"-","text":"We use two keyword arguments, both are optional: padding, and  atend.","category":"page"},{"location":"design/approach/","page":"-","title":"-","text":"This allows three call states for each approach","category":"page"},{"location":"design/approach/","page":"-","title":"-","text":"<approach>(windowed_fn, window_width, data_seq)\n<approach>(windowed_fn, window_width, data_seq; padding=pad)\n<approach>(windowed_fn, window_width, data_seq; padding=pad, atend=true)","category":"page"},{"location":"design/approach/","page":"-","title":"-","text":"For every approach, there are four data configurations:","category":"page"},{"location":"design/approach/","page":"-","title":"-","text":"one vector\ntwo vectors (of equal length)\nthree vectors (of equal length)\na matrix of 2 or more columns","category":"page"},{"location":"design/approach/","page":"-","title":"-","text":"For every approach, the data sequence may be weighted.  There are three ways to introduce weights:","category":"page"},{"location":"design/approach/","page":"-","title":"-","text":"for any data configuration\nas a vector where isa(vector, StatsBase.AbstractWeights)\nfor multiple data sequences or a data matrix\nas a vector where isa(vector, Vector{<:StatsBase.AbstractWeights})\nas a matrix where isa(matrix, <:Matrix{Number})","category":"page"},{"location":"use/rolling/#about-rolling","page":"-","title":"about rolling","text":"","category":"section"},{"location":"use/rolling/","page":"-","title":"-","text":"using RollingFunctions\n\n𝐷𝑎𝑡𝑎 = [1, 2, 3, 4, 5]\n𝐹𝑢𝑛𝑐 = sum\n𝑆𝑝𝑎𝑛 = 3\n\nrolled = rolling(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛)\n\n\njulia> rolled\n3-element Vector{Int64}:\n  6\n  9\n 12\n\n#=\nThe first  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the first  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.\nThe second windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the second 𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.\nThe third  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the third  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.\n\nThere can be no fourth value as the third value used the fins entries in𝐷𝑎𝑡𝑎.\n=#\n\njulia> sum(𝐷𝑎𝑡𝑎[1:3]), sum(𝐷𝑎𝑡𝑎[2:4]), sum(𝐷𝑎𝑡𝑎[3:5])\n(6, 9, 12)\n\n\nIf the width of each subsequence increases to 4..\n\n𝑆𝑝𝑎𝑛 = 4\nrolled = rolling(𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛, 𝒮);\n\nrolled\n2-element Vector{Int64}:\n 10\n 14","category":"page"},{"location":"use/rolling/","page":"-","title":"-","text":"Generally, with data that has r rows using a width of s results in r - s + 1 rows of values.","category":"page"},{"location":"use/rolling/#with-matricies","page":"-","title":"with matricies","text":"","category":"section"},{"location":"use/rolling/","page":"-","title":"-","text":"#=\n\nYou have n data vectors of equal length (rowcount 𝓇)\n𝐷𝑎𝑡𝑎₁ .. 𝐷𝑎𝑡𝑎ᵢ .. 𝐷𝑎𝑡𝑎ₙ  collected as an 𝓇 x 𝓃 matrix 𝑀\nyou want to apply the same function (sum)\nto colum-wise triple row subsequences, successively\n\n=#\n\nusing RollingFunctions\n\n𝐷𝑎𝑡𝑎₁ = [1, 2, 3, 4, 5]\n𝐷𝑎𝑡𝑎₂ = [5, 4, 3, 2, 1]\n𝐷𝑎𝑡𝑎₃ = [1, 2, 3, 2, 1]\n\n𝑀 = hcat(𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝐷𝑎𝑡𝑎₃);\n\n#=\njulia> 𝑀\n5×3 Matrix{Int64}:\n 1  5  1\n 2  4  2\n 3  3  3\n 4  2  2\n 5  1  1\n=#\n\n𝐹𝑢𝑛𝑐 = sum\n𝑆𝑝𝑎𝑛 = 3\n\nresult = rolling(𝐹𝑢𝑛𝑐, 𝑀, 𝑆𝑝𝑎𝑛)\n\n#=\njulia> result\n3×3 Matrix{Int64}:\n  6  12  6\n  9   9  7\n 12   6  6\n=#\n","category":"page"},{"location":"use/rolling/#multicolumn-functions","page":"-","title":"multicolumn functions","text":"","category":"section"},{"location":"use/rolling/","page":"-","title":"-","text":"#=\n\nYou have n data vectors of equal length (rowcount 𝓇)\n𝐷𝑎𝑡𝑎₁ .. 𝐷𝑎𝑡𝑎ᵢ .. 𝐷𝑎𝑡𝑎ₙ\nyou apply a function (StatsBase.cor) of n==2 arguments\nto subsequences of width 3 (over successive triple rows)\n\n=#\n\nusing RollingFunctions\n\n𝐷𝑎𝑡𝑎₁ = [1, 2, 3, 4, 5]\n𝐷𝑎𝑡𝑎₂ = [5, 4, 3, 2, 1]\n\n𝐹𝑢𝑛𝑐 = cor\n𝑆𝑝𝑎𝑛 = 3\n\nresult = rolling(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎₁,𝐷𝑎𝑡𝑎₂, 𝑆𝑝𝑎𝑛)\n#=\n3-element Vector{Float64}:\n  -1.0\n  -1.0\n  -1.0\n=#\n","category":"page"},{"location":"use/rolling/#[approaching-rolling](../approach/rolling.md)","page":"-","title":"approaching rolling","text":"","category":"section"},{"location":"approach/tapering/","page":"-","title":"-","text":"    _tapering_","category":"page"},{"location":"approach/tiling/","page":"-","title":"-","text":"tiling(tiling_fn, window_width, data_seq)\n\ntiling(fn, width, data; padding=nopadding)\ntiling(fn, width, data; padding, atend=false)","category":"page"},{"location":"approach/tiling/","page":"-","title":"-","text":"tiling a function over windowed data repeatedly applies that function to each adjacent data subsequence that the moving window provides.  The length of each subsequence is given by the width of the window.","category":"page"},{"location":"approach/tiling/","page":"-","title":"-","text":"The function is applied as if it gathers the data spanned and consumes it all at once.  The function is one that summarizes, condeneses, abstracts, characterizes, or explores contiguous subsequences shown by the moving window.","category":"page"},{"location":"approach/tiling/","page":"-","title":"-","text":"While the window is fully contained within the data, each step (one tile) increments the indices of the current window: (start:finish)  ↦  (start+width:finish+width) == (finish+1:finish+width). When advancing the window would carry the end of the window beyond the end of the data, tiling is complete.","category":"page"},{"location":"approach/tiling/","page":"-","title":"-","text":"With N data values and a window of width W (W<=N), the result from tiling will have no more than div(N, W) values. There will be rem(N, W) left over (untiled) values. Using the keyword padding, will pad the first or final (atend=true) return value when rem(N, W) != 0.","category":"page"},{"location":"approach/tiling/","page":"-","title":"-","text":"arguments","category":"page"},{"location":"approach/tiling/","page":"-","title":"-","text":"fn::Function:     summarizes, condenses windowed data\nwidth::Integer:   window breadth, counts covered elements.\ndata::Vector:     the data over which the window moves.","category":"page"},{"location":"approach/tiling/","page":"-","title":"-","text":"keywords","category":"page"},{"location":"approach/tiling/","page":"-","title":"-","text":"padding::Any=nopadding: the value place as filler.\natend::Bool=false:      where to place the padding.","category":"page"},{"location":"approach/tiling/#[using-tiling](../use/tiling.md)","page":"-","title":"using tiling","text":"","category":"section"},{"location":"approach/tiling/","page":"-","title":"-","text":"See also: rolling,           running           padding,            atend,           weighs,           datastreams","category":"page"},{"location":"diagrams/running/","page":"running","title":"running","text":"(Image: Sequential_Data_Streams)","category":"page"},{"location":"use/running/","page":"-","title":"-","text":"using RollingFunctions\n\n𝐷𝑎𝑡𝑎 = [1, 2, 3, 4, 5]\n𝐹𝑢𝑛𝑐 = sum\n𝑆𝑝𝑎𝑛 = 3\n\nresult = running(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛)\njulia> result\n3-element Vector{Int64}:\n  6\n  9\n 12\n\n#=\nThe first  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the first  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.\nThe second windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the second 𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.\nThe third  windowed value is the 𝐹𝑢𝑛𝑐 (sum) of the third  𝑆𝑝𝑎𝑛 (3) values in 𝐷𝑎𝑡𝑎.\n\nThere can be no fourth value as the third value used the fins entries in𝐷𝑎𝑡𝑎.\n=#\n\njulia> sum(𝐷𝑎𝑡𝑎[1:3]), sum(𝐷𝑎𝑡𝑎[2:4]), sum(𝐷𝑎𝑡𝑎[3:5])\n(6, 9, 12)\n\nIf the width of each subsequence increases to 4..\n𝑆𝑝𝑎𝑛 = 4\nresult = running(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛);\n\nresult\n2-element Vector{Int64}:\n 10\n 14","category":"page"},{"location":"use/running/#[approaching-running](../approach/running.md)","page":"-","title":"approaching running","text":"","category":"section"},{"location":"thanks/","page":"Thanks","title":"Thanks","text":"There have been many who contributed.","category":"page"},{"location":"thanks/","page":"Thanks","title":"Thanks","text":"These people have done more, some without trying.","category":"page"},{"location":"thanks/","page":"Thanks","title":"Thanks","text":"thanks \nEliot Saba @staticfloat\nBogumił Kamiński @bkamins\nMiguel Raz Guzmán Macedo @miguelraz\nTyler Beason @tbeason\nKevin Patel @kevindirect","category":"page"},{"location":"tech/windowmath/","page":"-","title":"-","text":"𝐷𝑎𝑡𝑎𝐷𝑎𝑡𝑎ₗₑₙ 𝑆𝑝𝑎𝑛 𝑆𝑝𝑎𝑛ₗₑₙ  𝒯 𝒯ₗₑₙ  𝒫 𝒫ₗₑₙ  𝒪 𝒪⁺ 𝒪⁻","category":"page"},{"location":"tech/windowmath/","page":"-","title":"-","text":"𝐷𝑎𝑡𝑎𝐷𝑎𝑡𝑎ₙ 𝑆𝑝𝑎𝑛 𝑆𝑝𝑎𝑛ₙ  𝒯 𝒯ₙ  𝒫 𝒫ₙ  𝒪 𝒪⁺ 𝒪⁻ ⁺𝒪ₙ ⁻𝒪ₙ","category":"page"},{"location":"tech/windowmath/","page":"-","title":"-","text":"We accept a data sequence𝐷𝑎𝑡𝑎𝒮 of type Vector{T} and of length𝐷𝑎𝑡𝑎𝒮ₙ (𝐷𝑎𝑡𝑎𝒮[begin:end], length(𝐷𝑎𝑡𝑎𝒮) ==𝐷𝑎𝑡𝑎𝒮ₙ). We are given a window specification that includes its length, the width of any tiling, and more.","category":"page"},{"location":"tech/windowmath/","page":"-","title":"-","text":"Given a data seqeunce of N elements and a window that widths W elements (W <= N),     ccompletewindows, rremainingindices = fldmod(N, W)     if iszero(remainingelements) the data sequence is covered exactly with ccompletewindows     otherwise, the data sequence is nearly fully covered with ccompletewindows, leaving rremaining_indices","category":"page"},{"location":"tech/windowmath/","page":"-","title":"-","text":"N = c_complete_windows * W + r_remaining_indices\n0 = c_complete_windows * W + r_remaining_indices - N\nc_complete_windows * W = N - r_remaining_indices\nc_complete_windows = div((N - r_remaining_indices), W)\nW = div((N - r_remaining_indices), c_complete_windows)\nr_remaining_indices = N - c_complete_windows * W","category":"page"},{"location":"tech/windowmath/","page":"-","title":"-","text":"The preceeding assumes that the window always advances by 1 index. Use A as the whole number of indices (1 <= A <= N-1-W) that window always advances. With A = N-1-W, there is exactly one advance, from index 1 to index 1+N-1-W = N-W    the repositioned window now starts at index N-W and widths W indices, N-W+W == N    and the window has nowhere more to traverse.","category":"page"},{"location":"tech/windowmath/","page":"-","title":"-","text":"What value of A allows exactly 2 advances?     A1 = N-1-W, if iseven(A1) A2 = div(A1,2)     or, if isodd(N-W), A2 = div(N-W-1, 2)","category":"page"},{"location":"use/padding/","page":"-","title":"-","text":"under construction (see tests)","category":"page"},{"location":"use/padding/","page":"-","title":"-","text":"You may pad the result with the value of your choice","category":"page"},{"location":"use/padding/#padding-is-a-keyword-argument","page":"-","title":"padding is a keyword argument","text":"","category":"section"},{"location":"use/padding/","page":"-","title":"-","text":"if you assign e.g. padding = missing, the result will be padfirst\nyou may pad using any defined value and all types except Nothing\nexample pads(missing, 0, nothing, NaN, '∅', AbstractString)","category":"page"},{"location":"use/padding/","page":"-","title":"-","text":"using RollingFunctions\n\n𝐷𝑎𝑡𝑎 = [1, 2, 3, 4, 5]\n𝐹𝑢𝑛𝑐 = sum\n𝑆𝑝𝑎𝑛 = 3\n\nresult = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = missing);\n#=\njulia> result\n5-element Vector{Union{Missing, Int64}}:\n   missing\n   missing\n  6\n  9\n 12\n=#\n \nresult = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = zero(eltype(𝐷𝑎𝑡𝑎));\n#=\njulia> result\n5-element Vector{Int64}:\n  0\n  0\n  6\n  9\n 12\n=#","category":"page"},{"location":"use/padding/#Give-me-the-real-values-first,-pad-to-the-end.","page":"-","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"use/padding/","page":"-","title":"-","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = missing, atend=true);\n#=\njulia> result\n5-element Vector{Union{Missing,Int64}}:\n  6\n  9\n 12\n  missing\n  missing\n=#","category":"page"},{"location":"use/padding/","page":"-","title":"-","text":"technical aside: this is not the same as reverse(rolling(𝐹𝑢𝑛𝑐,𝐷𝑎𝑡𝑎, 𝑆𝑝𝑎𝑛; padding = zero(eltype(𝐷𝑎𝑡𝑎)).","category":"page"},{"location":"use/padding/#padding-matrices","page":"-","title":"padding matrices","text":"","category":"section"},{"location":"use/padding/","page":"-","title":"-","text":"using RollingFunctions","category":"page"},{"location":"use/padding/","page":"-","title":"-","text":"𝐷𝑎𝑡𝑎₁ = [1, 2, 3, 4, 5] 𝐷𝑎𝑡𝑎₂ = [5, 4, 3, 2, 1] 𝐷𝑎𝑡𝑎₃ = [1, 2, 3, 2, 1]","category":"page"},{"location":"use/padding/","page":"-","title":"-","text":"𝑀 = hcat(𝐷𝑎𝑡𝑎₁,𝐷𝑎𝑡𝑎₂,𝐷𝑎𝑡𝑎₃) #= 5×3 Matrix{Int64}:  1  5  1  2  4  2  3  3  3  4  2  2  5  1  1 =#","category":"page"},{"location":"use/padding/","page":"-","title":"-","text":"𝐹𝑢𝑛𝑐 = sum 𝑆𝑝𝑎𝑛 = 3","category":"page"},{"location":"use/padding/","page":"-","title":"-","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝑀, 𝑆𝑝𝑎𝑛; padding=missing) #= 5×3 Matrix{Union{Missing,Int64}}: missing missing missing missing missing missing   6  12  6   9   9  7  12   6  6 =#","category":"page"},{"location":"use/padding/#Give-me-the-real-values-first,-pad-to-the-end.-2","page":"-","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"use/padding/","page":"-","title":"-","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝑀, 𝑆𝑝𝑎𝑛; padding = missing, atend=true) #= 5×3 Matrix{Union{Missing,Int64}}:   6  12  6   9   9  7  12   6  6    missing    missing   missing    missing    missing   missing =#","category":"page"},{"location":"use/padding/#multicolumn-padding","page":"-","title":"multicolumn padding","text":"","category":"section"},{"location":"use/padding/","page":"-","title":"-","text":"You may pad the result with the value of your choice","category":"page"},{"location":"use/padding/#padding-is-a-keyword-argument-2","page":"-","title":"padding is a keyword argument","text":"","category":"section"},{"location":"use/padding/","page":"-","title":"-","text":"if you assign e.g. padding = missing, the result will be padfirst\nyou may pad using any defined value and all types except Nothing\nexample pads(missing, 0, nothing, NaN, '∅', AbstractString)","category":"page"},{"location":"use/padding/","page":"-","title":"-","text":"using RollingFunctions\n\n𝐷𝑎𝑡𝑎₁ = [1, 2, 3, 4, 5]\n𝐷𝑎𝑡𝑎₂ = [5, 4, 3, 2, 1]\n\n𝐹𝑢𝑛𝑐 = cov\n𝑆𝑝𝑎𝑛 = 3\n\nresult = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝑆𝑝𝑎𝑛; padding = zero(eltype(𝑀)))\n\n#=\njulia> result\n5 element Vector {Float64}:\n  0.0\n  0.0\n -1.0\n -1.0\n -1.0\n=#","category":"page"},{"location":"use/padding/#Give-me-the-real-values-first,-pad-to-the-end.-3","page":"-","title":"Give me the real values first, pad to the end.","text":"","category":"section"},{"location":"use/padding/","page":"-","title":"-","text":"result = rolling(𝐹𝑢𝑛𝑐, 𝐷𝑎𝑡𝑎₁, 𝐷𝑎𝑡𝑎₂, 𝑆𝑝𝑎𝑛; padding = missing, atend=true)\n\n#=\n5 element Vector {Float64}:\n -1.0\n -1.0\n -1.0\n  missing\n  missing\n=#","category":"page"},{"location":"use/padding/#[approaching-padding](../approach/padding.md)","page":"-","title":"approaching padding","text":"","category":"section"},{"location":"use/weights/","page":"-","title":"-","text":"under construction (see tests)","category":"page"},{"location":"use/weights/#[approaching-weights](../approach/weights.md)","page":"-","title":"approaching weights","text":"","category":"section"},{"location":"approach/atend/","page":"atend","title":"atend","text":"    atend -- optional keyword argument","category":"page"},{"location":"approach/atend/","page":"atend","title":"atend","text":"atend is a keyword argument that defaults to false.","category":"page"},{"location":"approach/atend/","page":"atend","title":"atend","text":"additional value[s] are placed at the start of the results.","category":"page"},{"location":"approach/atend/","page":"atend","title":"atend","text":"using atend = true","category":"page"},{"location":"approach/atend/","page":"atend","title":"atend","text":"additional value[s] are placed at the end (highest indices).","category":"page"},{"location":"approach/atend/","page":"atend","title":"atend","text":"By default, padding is applied at the begining of the result.","category":"page"},{"location":"approach/atend/","page":"atend","title":"atend","text":"the padding value is placed at the lowest indices","category":"page"},{"location":"approach/atend/","page":"atend","title":"atend","text":"To apply padding at the end of the result, set atend=true.","category":"page"},{"location":"approach/atend/","page":"atend","title":"atend","text":"the padding value is placed at the highest indices","category":"page"},{"location":"approach/atend/#[using-atend](../use/atend.md)","page":"atend","title":"using atend","text":"","category":"section"},{"location":"approach/atend/","page":"atend","title":"atend","text":"See also: padding,           rolling,           tiling,           running","category":"page"},{"location":"approach/rolling/","page":"-","title":"-","text":"rolling(rolling_fn, window_width, data_seq)\n\nrolling(fn, width, data; padding=nopadding)\nrolling(fn, width, data; padding, atend=false)","category":"page"},{"location":"approach/rolling/","page":"-","title":"-","text":"rolling a function over windowed data repeatedly applies that function to each overlapping data subsequence that the moving window provides.  The length of each subsequence is given by the width of the window.","category":"page"},{"location":"approach/rolling/","page":"-","title":"-","text":"The function is applied as if it gathers the data spanned and consumes it all at once.  The function is one that summarizes, condeneses, abstracts, characterizes, or explores  subsequences shown by the moving window.","category":"page"},{"location":"approach/rolling/","page":"-","title":"-","text":"While the window is fully contained within the data, each step (one roll) increments the indices of the current window: (start:finish)  ↦  (start+1:finish+1). When advancing the window would carry the end of the window beyond the end of the data, rolling is complete.","category":"page"},{"location":"approach/rolling/","page":"-","title":"-","text":"With N data values and a window of width W (W<=N), the result from rolling will have no more than N-(W-1) == N-W+1 values.  W-1 values are consumed in preparing to cover the first window.  The result may have fewer values, it depends on whether or not W divides N exactly.  To get a result of length N, use the keyword padding.","category":"page"},{"location":"approach/rolling/","page":"-","title":"-","text":"arguments","category":"page"},{"location":"approach/rolling/","page":"-","title":"-","text":"fn::Function:   summarizes, condenses windowed data\nwidth::Integer:   window breadth, counts covered elements.\ndata::Vector:     the data over which the window moves.","category":"page"},{"location":"approach/rolling/","page":"-","title":"-","text":"keywords","category":"page"},{"location":"approach/rolling/","page":"-","title":"-","text":"padding::Any=nopadding: the value place as filler.\natend::Bool=false:     where to place the padding.","category":"page"},{"location":"approach/rolling/#[using-rolling](../use/rolling.md)","page":"-","title":"using rolling","text":"","category":"section"},{"location":"approach/rolling/","page":"-","title":"-","text":"See also: tiling,           running,           padding,            atend,           weights,           datastreams","category":"page"},{"location":"design/futures/#**FUTURE-CAPABILITIES-(maybe)**","page":"Future Dev","title":"FUTURE CAPABILITIES (maybe)","text":"","category":"section"},{"location":"design/futures/#*these-operations-are-under-consideration*","page":"Future Dev","title":"these operations are under consideration","text":"","category":"section"},{"location":"design/futures/#Proportional-Tapering","page":"Future Dev","title":"Proportional Tapering","text":"","category":"section"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"The call to running above has three keyword arguments.  In the first example, their default values were used.  Fully elaborated, that call becomes:","category":"page"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"running(sum, width, data; padding=nopadding, atend=false, scale=false)","category":"page"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"To scale tapered value by width / current_taper_length,use scale=true.","category":"page"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"# using sum with scaled tapering (at start, the default)\r\n        (1 * 3/1,), ((1+2) * 3/2), (1+2+3), (2+3+4), (3+4+5), (4+5+6)\r\n        (3.0,         4.5,          6.0,     9.0,     12.0,    15.0)\r\nrunning(sum, width, data; scale=true)              == (3.0, 4.5, 6.0, 9.0, 12.0, 15.0)\r\nrunning(sum, width, data; atend=false, scale=true) == (3.0, 4.5, 6.0, 9.0, 12.0, 15.0)\r\n\r\n# using sum with scaled tapering at the end\r\n        (1+2+3), (2+3+4), (3+4+5), (4+5+6), ((5+6) * 3/2,), (6 * 3/1,)\r\n        (6.0,     9.0,     12.0,    15.0,    16.5,           18.0)\r\nrunning(sum, width, data; atend=true, scale=true) == (6.0, 9.0, 12.0, 15.0, 16.5, 18.0)","category":"page"},{"location":"design/futures/#Hopping","page":"Future Dev","title":"Hopping","text":"","category":"section"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"this is the general case for moving windows","category":"page"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"data      = [1, 2, 3, 4, 5, 6]  # here, a single vector\r\nnitems    = n  # length(data)\r\nwidth     = w  # a window covering `w` indices at a time\r\nslide     = s  # the window advances in steps of `±s` indices\r\nhop       = h  # the window skips `±h` indices before sliding\r\nindexfrom = i  # the initial window starts at index `i`","category":"page"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"slide, hop, indexfrom must make sense given nitems and width","category":"page"},{"location":"design/futures/#constraints","page":"Future Dev","title":"constraints","text":"","category":"section"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"1 <= width     <= nitems\n1 <= indexfrom <= nitems\n(width-nitems) <= slide <= (nitems-width)\n(width-nitems) <= hop   <= (nitems-width)","category":"page"},{"location":"design/futures/#orientation","page":"Future Dev","title":"orientation","text":"","category":"section"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"orientation = sign(hop + slide)","category":"page"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"orientation is positive\nthe window moves from lower indices to higher indices\nindexfrom + width <= nitems\norientation is negative\nthe window moves from higher indices to lower indices\nindexfrom - width >= 1\norientation is zero\n(the moving window does not move)\nthe function is applied once, the result is a single value\nit is likely that this is a client error","category":"page"},{"location":"design/futures/#Windowing-in-2D","page":"Future Dev","title":"Windowing in 2D","text":"","category":"section"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"Substantive image processing becomes available with 2D moving windows.","category":"page"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"image [is an image stored as] pixel values within a [rectangular] matrix.\nwinsize = (rows spanned, columns spanned) by the window\nwinoffset = winsize .- 1\nwinmove = advance window by (nrows, ncolumns)\nwinstart = (initial row, initial column) for window upper left\nwinstop  = winstart .+ winoffset","category":"page"},{"location":"design/futures/#*the-initial-and-the-next-windows*","page":"Future Dev","title":"the initial and the next windows","text":"","category":"section"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"Base.:(+)(start::T, move::T) where {I<:Integer, T<:NTuple{2,I}} =\r\n    (start[1]+move[1], start[2]+move[2])\r\nBase.:(-)(start::T, move::T) where {I<:Integer, T<:NTuple{2,I}} =\r\n    (start[1]-move[1], start[2]-move[2])\r\n\r\nimage = reshape(1:5^2, (5,5))\r\n#= 5×5 reshape(::UnitRange{Int64}, 5, 5) with eltype Int64:\r\n 1   6  11  16  21\r\n 2   7  12  17  22\r\n 3   8  13  18  23\r\n 4   9  14  19  24\r\n 5  10  15  20  25\r\n=#\r\n\r\nwinstart = (1, 1)\r\nwinstop  = (3, 3)\r\nwinmove  = (2, 2)\r\n\r\nintial_window_content =\r\n    image[CartesianIndex(winstart):CartesianIndex(winstop)]\r\n#= 3×3 Matrix{Int64}:\r\n 13  18  23\r\n 14  19  24\r\n 15  20  25\r\n=#\r\n\r\nwinstart += winmove\r\nwinstop  += winmove\r\n\r\nnext_window_content =\r\n   image[CartesianIndex(winstart):CartesianIndex(winstop)]\r\n#= 3×3 Matrix{Int64}:\r\n 13  18  23\r\n 14  19  24\r\n 15  20  25\r\n=#","category":"page"},{"location":"design/futures/#*moving-through-a-recursive-Z-pattern*","page":"Future Dev","title":"moving through a recursive Z pattern","text":"","category":"section"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"uses","category":"page"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"erosion, dilation, opening, closing, thinning, thickening","category":"page"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"max indices","category":"page"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"# 2D\r\njulia> x=2^16; morton=cartesian2morton([x,x]); match= ([x,x]==morton2cartesian(morton));\r\njulia> (; coords=:xy, x, morton, match)\r\n(coords = :xy, x = 65536, morton = 4294967296, match = true)\r\n\r\n# 3D\r\njulia> x=2^10; morton=cartesian3morton([x,x,x]); match= ([x,x,x]==morton3cartesian(morton));\r\njulia> (; coords=:xyz, x, morton, match)\r\n(coords = :xyz, x = 1024, morton = 1073741824, match = true)\r\n","category":"page"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"refs","category":"page"},{"location":"design/futures/","page":"Future Dev","title":"Future Dev","text":"wikipedia\nMorton coding\nTiledViews\nTiledIteration","category":"page"},{"location":"#Introducing-Windowed-Functions","page":"Home","title":"Introducing Windowed Functions","text":"","category":"section"},{"location":"#**apply-functions-over-data-through-moving-windows**","page":"Home","title":"apply functions over data through moving windows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"\nWindowedFunctions.jl © 2017-2023 by Jeffrey Sarnoff.\nThis work product is released under the MIT License.\n","category":"page"},{"location":"#Rolling","page":"Home","title":"Rolling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"data  = [1, 2, 3, 4, 5, 6]  # here, a single vector\nwidth = 3  # a window covering 3 indices at a time\nslide = 1  # the window advances in steps of 1 index\n\n# the moving window covers\n        (1,2,3), (2,3,4), (3,4,5), (4,5,6)   # windowed data\n\n# using sum\n        (1+2+3), (2+3+4), (3+4+5), (4+5+6)\n        (6,       9,       12,      15)      # the result\n\nrolling(sum, width, data) == (6, 9, 12, 15)  # this package","category":"page"},{"location":"","page":"Home","title":"Home","text":"rolling means the slide == 1 With basic rolling, the result has length(data) - (width - 1) entries. Often, it is useful to generate a result with length matching the length of the data. This requires padding the (width - 1) entries that would have been omitted with some designated filler value. These fillers may be placed at the start of the result or at the end of the result.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The call to rolling above has two keyword arguments.  In the first example, their default values were used.  Fully elaborated, that call becomes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"rolling(sum, width, data; padding=nopadding, atend=false)","category":"page"},{"location":"","page":"Home","title":"Home","text":"data    = [1, 2, 3, 4, 5, 6]\nwidth   = 3 # a window covering 3 indices at a time\nslide   = 1 # the window advances in steps of 1 index\npadding = 0 # the filler value\n\n# the moving window covers\n        (1,2,3), (2,3,4), (3,4,5), (4,5,6)   # windowed data\n\n# using sum\n        (6,       9,       12,      15)      # the result\nrolling(sum, width, data) == (6, 9, 12, 15)  # this package\n\n# using sum with padding (at start, the default)\n        (0, 0, 6, 9, 12, 15)                 # the result\nrolling(sum, width, data; padding=0) == (0, 0, 6, 9, 12, 15)\n\n# using sum with padding at the end\n        (6, 9, 12, 15, 0, 0)                 # the result\nrolling(sum, width, data; padding=0, atend=true) == (6, 9, 12, 15, 0, 0)","category":"page"},{"location":"#Tiling","page":"Home","title":"Tiling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"tiling slides the window just past its current ending index.","category":"page"},{"location":"","page":"Home","title":"Home","text":"it is similar to rolling, and it is used the same way.","category":"page"},{"location":"","page":"Home","title":"Home","text":"data  = [1, 2, 3, 4, 5, 6]  # here, a single vector\nwidth = 3      # a window covering 3 indices at a time\nslide = width  # the window advances over itself\n\n# the moving window covers\n        (1,2,3), (4,5,6)      # windowed data\n\n# using sum\n        (1+2+3), (4+5+6)\n        (6,       15,  )      # the result\n\ntiling(sum, width, data) == (6, 15)  # this package","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the above example, all of the data was used (seen by the moving window). When tiling, that occurs if and only if mod(length(data), width) == 0. Otherwise, one or more (at most width-1) data items will not be seen.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The call to tiling above has two keyword arguments.  In the first example, their default values were used.  Fully elaborated, that call becomes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"tiling(sum, width, data; padding=nopadding, atend=false)","category":"page"},{"location":"","page":"Home","title":"Home","text":"data  = [1, 2, 3, 4, 5, 6, 7, 8]\nwidth = 3      # a window covering 3 indices at a time\nslide = width  # the window advances over itself\nomitted = mod(length(data), width) # 2 indices do not contribute to the result\n\n# the moving window either\n#       covers [default]  or  covers [atend=true]\n        (1,2,3), (4,5,6)      (3,4,5), (6,7,8)    # the possible windowed data\n\n# using sum\n        (1+2+3), (4+5+6)  or  (3+4+5), (6+7+8)\n        (6,       15,  )      (12,      21   )    # the possible results\n\ntiling(sum, width, data) == (6, 15)               # this package\ntiling(sum, width, data; atend=true) == (12, 21)  # this package","category":"page"},{"location":"","page":"Home","title":"Home","text":"When tiling covers the data incompletely, padding is available:","category":"page"},{"location":"","page":"Home","title":"Home","text":"if there is an incomplete tile mod(length(data), width) != 0\nthat omitted tile is replaced with the padding value\nat most 1 tile is incomplete, so there can be at most 1 index padded","category":"page"},{"location":"","page":"Home","title":"Home","text":"tiling(sum, width, data; padding=missing)              == (missing, 6, 15)\ntiling(sum, width, data; padding=missing, atend=false) == (missing, 6, 15)\ntiling(sum, width, data; padding=missing, atend=true)  == (12, 21, missing)","category":"page"},{"location":"#Running","page":"Home","title":"Running","text":"","category":"section"},{"location":"#*tapering-functions*","page":"Home","title":"tapering functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Padding is very helpful, it simplifies handling.  It does require selecting a single value to use as the pad. While any value that makes sense within the context of the data sequence may be used, it is not always obvious what value is best. If your handling supports (even better, resolves) missing, then that is a fine and generally robust choice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Otherwise, with numeric data it is desireable to use a padding value that is unlikely to warp the information you are gathering.  Zero is the neutral value for additive processing. One is the neutral value for multiplicative processing.  For more involved processing, any predetermined choice may be inelegant with certain data sequences.  You may want to take some local estimator as the pad value, precomputing a short sample.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package offers an alternative approach, tapering. Rather than pad with a preselected value, tapering determines the values to be appended using the same windowing function over successively forshortened windows.","category":"page"},{"location":"#running-functions-through-moving-windows-onto-data","page":"Home","title":"running functions through moving windows onto data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"running is a variation on rolling that replaces padding with tapering.","category":"page"},{"location":"","page":"Home","title":"Home","text":"data    = [1, 2, 3, 4, 5, 6]\nwidth   = 3 # a window covering 3 indices at a time\nslide   = 1 # the window advances in steps of 1 index\n\n# the moving window covers\n        (1,2,3), (2,3,4), (3,4,5), (4,5,6)   # windowed data\n\n# using sum\n        (1+2+3), (2+3+4), (3+4+5), (4+5+6)\n        (6,       9,       12,      15)      # the result\n\n# using sum with tapering (at start, the default)\n        (1,), (1+2), (1+2+3), (2+3+4), (3+4+5), (4+5+6)\n        (1,    3,     6,       9,       12,      15)      # the result\nrunning(sum, width, data) == (1, 3, 6, 9, 12, 15)         # this package\n","category":"page"},{"location":"approach/running/","page":"-","title":"-","text":"running(running_fn, window_width, data_seq)\n\nrunning(fn, width, data; padding=nopadding)\nrunning(fn, width, data; padding, atend=false)","category":"page"},{"location":"approach/running/","page":"-","title":"-","text":"running a function over windowed data repeatedly applies that function to each overlapping data subsequence that the moving window provides.  The length of each subsequence is given by the width of the window.","category":"page"},{"location":"approach/running/","page":"-","title":"-","text":"The function is applied as if it gathers the data spanned and consumes it all at once.  The function is one that summarizes, condeneses, abstracts, characterizes, or explores  subsequences shown by the moving window.","category":"page"},{"location":"approach/running/","page":"-","title":"-","text":"While the window is fully contained within the data, each step (one roll) increments the indices of the current window: (start:finish)  ↦  (start+1:finish+1). When advancing the window would carry the end of the window beyond the end of the data, running uses tapering.","category":"page"},{"location":"approach/running/","page":"-","title":"-","text":"To fill in the results where the window would be incomplete (where there is less data remaining than the window width), the function is applied to successively fewer data values. For functions that are undefined over a single value (e.g. skewness, covariance), the result of the final taper will be NaN unless you specify a padding value.","category":"page"},{"location":"approach/running/","page":"-","title":"-","text":"arguments","category":"page"},{"location":"approach/running/","page":"-","title":"-","text":"fn::Function:     summarizes, condenses windowed data\nwidth::Integer:   window breadth, counts covered elements.\ndata::Vector:     the data over which the window moves.","category":"page"},{"location":"approach/running/","page":"-","title":"-","text":"keywords","category":"page"},{"location":"approach/running/","page":"-","title":"-","text":"padding::Any=nopadding: the value place as filler.\natend::Bool=false:      where to place the padding.","category":"page"},{"location":"approach/running/#[using-running](../use/running.md)","page":"-","title":"using running","text":"","category":"section"},{"location":"approach/running/","page":"-","title":"-","text":"See also: tapering,           rolling,           padding,            atend,           weights,           datastreams","category":"page"}]
}
